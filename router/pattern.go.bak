package router

import (
	"fmt"
	"regexp"
	"strings"
)

// "Break characters" are characters that can end patterns. They are not allowed
// to appear in pattern names. "/" was chosen because it is the standard path
// separator, and "." was chosen because it often delimits file extensions. ";"
// and "," were chosen because Section 3.3 of RFC 3986 suggests their use.
const bc = "/.;,"

var patternRe = regexp.MustCompile(`[` + bc + `]:([^` + bc + `]+)`)

// StringPattern describes a parsed pattern
type StringPattern struct {
	Raw      string   // Raw (unparsed) pattern
	Pats     []string // Name of each pattern (i.e. pats[0] in "/:foo/:bar" is "foo")
	Breaks   []byte   // Break characters
	Literals []string // Literal component before a pattern
	Wildcard bool     // Has a wildcard match at the end?
}

// ParseStringPattern takes a Sinatra-style string pattern and decomposes it
// into its constituent components.
func ParseStringPattern(s string) StringPattern {
	raw := s

	// Check for wildcard matches, then trim the suffix if it's there.
	var wildcard bool
	if strings.HasSuffix(s, "/*") {
		s = s[:len(s)-1]
		wildcard = true
	}

	matches := patternRe.FindAllStringSubmatchIndex(s, -1)

	pats := make([]string, len(matches))
	breaks := make([]byte, len(matches))
	literals := make([]string, len(matches)+1)

	n := 0
	for i, match := range matches {
		a, b := match[2], match[3]
		literals[i] = s[n : a-1] // Need to leave off the colon
		pats[i] = s[a:b]

		// Break character at the end of the string is a '/', otherwise it's
		// the next character.
		if b == len(s) {
			breaks[i] = '/'
		} else {
			breaks[i] = s[b]
		}

		n = b
	}

	// Any remaining string is the last literal.
	literals[len(matches)] = s[n:]

	return StringPattern{
		raw:      raw,
		pats:     pats,
		breaks:   breaks,
		literals: literals,
		wildcard: wildcard,
	}
}

func (s StringPattern) String() string {
	return fmt.Sprintf("StringPattern(%q)", s.raw)
}

// JoinPatterns concatenates two string patterns.  This is a very minimal
// implementation - it essentially just checks for duplicate slashes, and
// errors when you attempt to join to a wildcard pattern (one ending in `/*`).
func JoinPatterns(one, two string) string {
	if strings.HasSuffix(one, "/*") {
		msg := fmt.Sprintf(`Invalid join attempted: cannot join %q pattern `+
			`on to pattern with a wildcard suffix (%q)`, two, one)
		panic(msg)
	}

	if strings.HasSuffix(one, "/") && strings.HasPrefix(two, "/") {
		two = two[1:]
	}

	return one + two
}
